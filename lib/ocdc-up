#!/usr/bin/env bash
#
# ocdc-up - Start a devcontainer with auto-assigned port
#
# Enables running multiple devcontainer instances simultaneously by:
#   - Auto-assigning ports from a configurable range (default: 13000-13099)
#   - Creating shallow clones for branch-based development (worktrees don't work with devcontainers)
#   - Generating ephemeral override configs (not checked into repo)
#   - Tracking port assignments to avoid conflicts
#
# Usage:
#   dcup                    # Start devcontainer for current directory
#   dcup <branch>           # Create clone for branch, start devcontainer
#   dcup --remove-existing  # Rebuild container from scratch
#   dcup --no-open          # Don't open VS Code (just start container)
#
# Examples:
#   cd ~/Projects/myapp && dcup              # Start on port 13000
#   cd ~/Projects/myapp && dcup feature-x    # Clone on port 13001
#
# The container's internal port (e.g., 3000) is mapped to the assigned host port.
# Access your app at http://localhost:<assigned-port>
#
# Behavior:
#   - In VS Code terminal: Opens clone in new VS Code window with devcontainer
#   - In other terminals: Prints cd command to navigate to clone
#
# Why clones instead of worktrees?
#   Git worktrees have a .git file pointing to the main repo's .git directory.
#   This path breaks inside containers since the main repo isn't mounted.
#   Clones are fully self-contained and work reliably with devcontainers.
#
# Related commands:
#   dcdown   - Stop container and release port
#   dclist   - List active instances
#   dcexec   - Execute command in container
#   dcgo     - Navigate to an existing clone
#
# Configuration:
#   ~/.config/ocdc/config.json
#   {
#     "portRangeStart": 13000,
#     "portRangeEnd": 13099
#   }

set -euo pipefail

# Source paths library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/../lib/ocdc-paths.bash"

# Run migration on first use
ocdc_migrate_paths

# Use new path variables (with backward-compatible aliases for readability)
CONFIG_DIR="$OCDC_CONFIG_DIR"
CONFIG_FILE="$OCDC_CONFIG_FILE"
CACHE_DIR="$OCDC_CACHE_DIR"
PORTS_FILE="$OCDC_PORTS_FILE"
OVERRIDES_DIR="$OCDC_OVERRIDES_DIR"
CLONES_DIR="$OCDC_CLONES_DIR"

# Defaults
DEFAULT_PORT_START=13000
DEFAULT_PORT_END=13099

# Parse arguments
BRANCH=""
REMOVE_EXISTING=false
NO_OPEN=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    --remove-existing|-r)
      REMOVE_EXISTING=true
      shift
      ;;
    --no-open|-n)
      NO_OPEN=true
      shift
      ;;
    --help|-h)
      sed -n '2,/^$/p' "$0" | sed 's/^# //' | sed 's/^#//'
      exit 0
      ;;
    -*)
      echo "Unknown option: $1" >&2
      exit 1
      ;;
    *)
      BRANCH="$1"
      shift
      ;;
  esac
done

# Detect if running in VS Code integrated terminal
is_vscode_terminal() {
  [[ -n "${TERM_PROGRAM:-}" ]] && [[ "$TERM_PROGRAM" == "vscode" ]]
}

# Ensure directories exist
ocdc_ensure_dirs

# Load configuration
PORT_START=$(jq -r ".portRangeStart // $DEFAULT_PORT_START" "$CONFIG_FILE")
PORT_END=$(jq -r ".portRangeEnd // $DEFAULT_PORT_END" "$CONFIG_FILE")

log() { echo "[ocdc-up] $*"; }
error() { echo "[ocdc-up] ERROR: $*" >&2; exit 1; }

# Check for devcontainer CLI
command -v devcontainer >/dev/null 2>&1 || error "devcontainer CLI not found. Install with: npm install -g @devcontainers/cli"

# Check we're in a git repo
git rev-parse --git-dir >/dev/null 2>&1 || error "Not in a git repository"

# Get repo info
REPO_ROOT=$(git rev-parse --show-toplevel)
REPO_NAME=$(basename "$REPO_ROOT")
REMOTE_URL=$(git remote get-url origin 2>/dev/null || echo "")

# Determine workspace directory
# Copy gitignored files from source repo to clone
# These files (secrets, local config, etc.) are needed for the app to run but aren't in git
# Skips directories with many gitignored files (dependencies) and large files
copy_gitignored_files() {
  local src="$1"
  local dst="$2"
  
  # Max file size to copy (100KB) - secrets/config are small
  local max_size=102400
  # Max gitignored files per top-level directory - secrets have few, dependencies have many
  local max_files_per_dir=10
  # Lock files to skip (generated, cause merge conflicts)
  local skip_files="package-lock.json|yarn.lock|pnpm-lock.yaml|Gemfile.lock|Cargo.lock|poetry.lock|composer.lock"
  
  # Get all gitignored files
  local gitignored_files
  gitignored_files=$(git -C "$src" ls-files --others --ignored --exclude-standard 2>/dev/null)
  [[ -z "$gitignored_files" ]] && return 0
  
  # Count gitignored files per top-level directory
  declare -A dir_file_counts=()
  while IFS= read -r rel_path; do
    [[ -z "$rel_path" ]] && continue
    local top_dir="${rel_path%%/*}"
    # If file is in root (no /), top_dir equals rel_path - use "." as key
    [[ "$top_dir" == "$rel_path" ]] && top_dir="."
    dir_file_counts["$top_dir"]=$(( ${dir_file_counts["$top_dir"]:-0} + 1 ))
  done <<< "$gitignored_files"
  
  # Copy files, skipping directories with too many gitignored files
  local copied=0
  while IFS= read -r rel_path; do
    [[ -z "$rel_path" ]] && continue
    
    # Skip lock files (generated, cause conflicts)
    local filename="${rel_path##*/}"
    if [[ "$filename" =~ ^($skip_files)$ ]]; then
      continue
    fi
    
    local top_dir="${rel_path%%/*}"
    [[ "$top_dir" == "$rel_path" ]] && top_dir="."
    
    # Skip if this top-level dir has too many gitignored files (likely dependencies)
    local count=${dir_file_counts["$top_dir"]:-0}
    if [[ $count -gt $max_files_per_dir ]]; then
      continue
    fi
    
    local src_file="$src/$rel_path"
    local dst_file="$dst/$rel_path"
    
    # Only copy files, not directories
    [[ -f "$src_file" ]] || continue
    
    # Skip if already exists
    [[ -f "$dst_file" ]] && continue
    
    # Skip large files
    local file_size
    file_size=$(stat -f%z "$src_file" 2>/dev/null || stat -c%s "$src_file" 2>/dev/null || echo 0)
    if [[ "$file_size" -gt "$max_size" ]]; then
      continue
    fi
    
    mkdir -p "$(dirname "$dst_file")"
    cp "$src_file" "$dst_file"
    log "Copied: $rel_path"
    ((copied++)) || true
  done <<< "$gitignored_files"
  
  if [[ $copied -gt 0 ]]; then
    log "Copied $copied gitignored file(s) to clone"
  fi
}

if [[ -n "$BRANCH" ]]; then
  # Branch specified - create/use clone
  CLONE_BASE="${CLONES_DIR}/${REPO_NAME}"
  WORKSPACE="${CLONE_BASE}/${BRANCH}"
  
  if [[ ! -d "$WORKSPACE" ]]; then
    mkdir -p "$CLONE_BASE"
    log "Creating clone for branch '$BRANCH'..."
    
    if [[ -n "$REMOTE_URL" ]]; then
      # Clone from remote with reference to save space
      if git clone --reference "$REPO_ROOT" --dissociate --branch "$BRANCH" "$REMOTE_URL" "$WORKSPACE" 2>/dev/null; then
        log "Created clone from remote branch '$BRANCH'"
      elif git clone --reference "$REPO_ROOT" --dissociate "$REMOTE_URL" "$WORKSPACE" 2>/dev/null; then
        # Branch doesn't exist remotely, create it locally
        cd "$WORKSPACE"
        git checkout -b "$BRANCH" 2>/dev/null || git checkout "$BRANCH"
        log "Created clone with new branch '$BRANCH'"
      else
        error "Failed to clone repository for branch '$BRANCH'"
      fi
    else
      # No remote, do a local clone
      git clone "$REPO_ROOT" "$WORKSPACE"
      cd "$WORKSPACE"
      git checkout -b "$BRANCH" 2>/dev/null || git checkout "$BRANCH"
      log "Created local clone with branch '$BRANCH'"
    fi
    
    # Copy over gitignored files from the source repo
    copy_gitignored_files "$REPO_ROOT" "$WORKSPACE"
  else
    log "Using existing clone at $WORKSPACE"
    # Update the clone
    cd "$WORKSPACE"
    git fetch origin 2>/dev/null || true
    git checkout "$BRANCH" 2>/dev/null || true
  fi
else
  WORKSPACE="$REPO_ROOT"
fi

# Check for devcontainer.json
if [[ ! -f "$WORKSPACE/.devcontainer/devcontainer.json" ]] && [[ ! -f "$WORKSPACE/.devcontainer.json" ]]; then
  error "No devcontainer.json found in $WORKSPACE"
fi

# Generate workspace identifier (hash of absolute path)
WORKSPACE_ID=$(ocdc_path_id "$WORKSPACE")

# Find available port
find_available_port() {
  for port in $(seq "$PORT_START" "$PORT_END"); do
    # Check if port is in use by system
    if ! lsof -i ":$port" >/dev/null 2>&1; then
      # Check if already assigned to another workspace
      local assigned_ws=$(jq -r --argjson p "$port" 'to_entries[] | select(.value.port == $p) | .key' "$PORTS_FILE" 2>/dev/null || true)
      if [[ -z "$assigned_ws" ]]; then
        echo "$port"
        return
      fi
    fi
  done
  error "No available ports in range $PORT_START-$PORT_END. Use 'dcdown' to stop unused instances or 'dclist' to see active ones."
}

# Get or assign port for this workspace
get_port() {
  local existing_port=$(jq -r --arg ws "$WORKSPACE" '.[$ws].port // empty' "$PORTS_FILE")
  if [[ -n "$existing_port" ]]; then
    echo "$existing_port"
  else
    find_available_port
  fi
}

PORT=$(get_port)

# Save port assignment
save_port() {
  local tmp=$(mktemp)
  jq --arg ws "$WORKSPACE" --argjson port "$PORT" --arg repo "$REPO_NAME" --arg branch "${BRANCH:-$(git -C "$WORKSPACE" branch --show-current 2>/dev/null || echo 'main')}" \
    '.[$ws] = {"port": $port, "repo": $repo, "branch": $branch, "started": now | todate}' \
    "$PORTS_FILE" > "$tmp" && mv "$tmp" "$PORTS_FILE"
}

# Read the original devcontainer.json to find the internal port
DEVCONTAINER_JSON="$WORKSPACE/.devcontainer/devcontainer.json"
[[ -f "$DEVCONTAINER_JSON" ]] || DEVCONTAINER_JSON="$WORKSPACE/.devcontainer.json"

# Try to detect internal port from runArgs or forwardPorts
INTERNAL_PORT=$(jq -r '
  (.runArgs // []) | map(select(test("^[0-9]+:[0-9]+$"))) | .[0] // "" | split(":") | .[1] // "",
  (.forwardPorts // []) | .[0] // ""
' "$DEVCONTAINER_JSON" 2>/dev/null | grep -v '^$' | head -1 || true)

# Default to 3000 if we couldn't detect
INTERNAL_PORT="${INTERNAL_PORT:-3000}"

# Also check for -p in runArgs (format: -p HOST:CONTAINER or -p CONTAINER)
if [[ -z "$INTERNAL_PORT" ]] || [[ "$INTERNAL_PORT" == "null" ]]; then
  INTERNAL_PORT=$(jq -r '
    (.runArgs // []) as $args |
    ($args | to_entries | map(select(.value == "-p")) | .[0].key // -1) as $idx |
    if $idx >= 0 then ($args[$idx + 1] // "" | split(":") | .[-1]) else "" end
  ' "$DEVCONTAINER_JSON" 2>/dev/null || echo "")
  INTERNAL_PORT="${INTERNAL_PORT:-3000}"
fi

# Generate merged config file (base config + our port override)
# Remove existing -p port mappings (both "-p" flag and the "HOST:PORT" value that follows)
OVERRIDE_FILE="${OVERRIDES_DIR}/${WORKSPACE_ID}.json"

# Compute the correct workspaceFolder based on the actual workspace directory name
# This is critical when using branch clones, as the original devcontainer.json may
# have a hardcoded workspaceFolder that doesn't match the clone directory name
WORKSPACE_BASENAME=$(basename "$WORKSPACE")
WORKSPACE_FOLDER="/workspaces/${WORKSPACE_BASENAME}"

jq --arg name "${REPO_NAME} (port ${PORT})" \
   --arg portmap "${PORT}:${INTERNAL_PORT}" \
   --arg workspaceFolder "$WORKSPACE_FOLDER" \
   '
   # Remove -p and its following port argument from runArgs
   def remove_port_args:
     if . == null then []
     else
       reduce .[] as $item (
         {result: [], skip_next: false};
         if .skip_next then {result: .result, skip_next: false}
         elif $item == "-p" then {result: .result, skip_next: true}
         elif ($item | test("^[0-9]+:[0-9]+$")) then {result: .result, skip_next: false}
         else {result: (.result + [$item]), skip_next: false}
         end
       ) | .result
     end;
   . + {name: $name, workspaceFolder: $workspaceFolder} | .runArgs = ((.runArgs | remove_port_args) + ["-p", $portmap])
   ' "$DEVCONTAINER_JSON" > "$OVERRIDE_FILE"

log "Workspace: $WORKSPACE"
log "Port mapping: localhost:$PORT -> container:$INTERNAL_PORT"

# Build devcontainer up arguments
UP_ARGS=(
  "--workspace-folder" "$WORKSPACE"
  "--override-config" "$OVERRIDE_FILE"
)

if [[ "$REMOVE_EXISTING" == "true" ]]; then
  UP_ARGS+=("--remove-existing-container")
  log "Removing existing container..."
fi

# Save port assignment before starting
save_port

log "Starting devcontainer..."
echo ""

# Run devcontainer up
if devcontainer up "${UP_ARGS[@]}"; then
  echo ""
  log "Devcontainer started successfully!"
  log "Access your app at: http://localhost:$PORT"
  echo ""
  
  # Open in VS Code if requested (not --no-open) and in VS Code terminal
  if [[ "$NO_OPEN" != "true" ]] && is_vscode_terminal; then
    log "Opening in VS Code devcontainer..."
    # Encode local workspace path as hex for vscode-remote URI
    HEX_PATH=$(printf '%s' "$WORKSPACE" | xxd -p -c 256 | tr -d '\n')
    code --folder-uri "vscode-remote://dev-container+${HEX_PATH}${WORKSPACE_FOLDER}"
  elif [[ -n "$BRANCH" ]]; then
    # For clones in non-VS Code terminals, show navigation help
    echo ""
    log "To navigate to the clone:"
    echo "  cd $WORKSPACE"
    echo ""
    log "Or use: dcgo $BRANCH"
  fi
  
  echo ""
  log "Useful commands:"
  log "  dcexec <cmd>     - Execute command in container"
  log "  dcdown           - Stop this container"
  log "  dclist           - List all instances"
  [[ -n "$BRANCH" ]] && log "  dcgo $BRANCH     - Navigate to this clone"
else
  # Clean up port assignment on failure
  tmp=$(mktemp)
  jq --arg ws "$WORKSPACE" 'del(.[$ws])' "$PORTS_FILE" > "$tmp" && mv "$tmp" "$PORTS_FILE"
  error "Failed to start devcontainer"
fi

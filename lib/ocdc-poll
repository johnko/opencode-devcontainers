#!/usr/bin/env bash
#
# ocdc-poll - Poll orchestrator for automated devcontainer sessions
#
# Usage:
#   ocdc poll [--once] [--dry-run] [--config <name>]
#   ocdc poll sessions           # List active poll sessions
#   ocdc poll attach <pattern>   # Attach to a session
#   ocdc poll logs [--follow]    # View poll logs
#
# Options:
#   --once      Run one poll cycle and exit (default)
#   --dry-run   Show what would be done without executing
#   --config    Only run specific config by id

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BIN_DIR="$(dirname "$SCRIPT_DIR")/bin"
source "${SCRIPT_DIR}/ocdc-paths.bash"
source "${SCRIPT_DIR}/ocdc-poll-config.bash"
source "${SCRIPT_DIR}/ocdc-file-lock.bash"

# Ensure ocdc commands are available
export PATH="$BIN_DIR:$PATH"

# State file for tracking processed items
STATE_FILE="${OCDC_POLL_STATE_DIR}/processed.json"

# Ensure state directory and file exist
mkdir -p "$OCDC_POLL_STATE_DIR"
mkdir -p "$OCDC_POLL_LOG_DIR"
[[ -f "$STATE_FILE" ]] || echo '{}' > "$STATE_FILE"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Options
DRY_RUN=false
SINGLE_CONFIG=""
VERBOSE=false
DAEMON=false
INTERVAL=300

# Current poll ID for structured logging
CURRENT_POLL_ID=""

# =============================================================================
# Logging with file output
# =============================================================================

# Rotate log file if it exceeds max lines
# Usage: rotate_log_if_needed [log_file] [max_lines] [keep_lines]
rotate_log_if_needed() {
  local log_file="${1:-$OCDC_POLL_LOG_FILE}"
  local max_lines="${2:-10000}"
  local keep_lines="${3:-5000}"
  
  [[ ! -f "$log_file" ]] && return 0
  
  local current_lines
  current_lines=$(wc -l < "$log_file" 2>/dev/null | tr -d ' ' || echo 0)
  
  if [[ $current_lines -gt $max_lines ]]; then
    local tmp_file="${log_file}.tmp"
    tail -n "$keep_lines" "$log_file" > "$tmp_file"
    mv "$tmp_file" "$log_file"
  fi
}

# Write log entry to file with timestamp and optional poll ID
_log_to_file() {
  local message="$1"
  
  # Ensure log directory exists
  mkdir -p "$OCDC_POLL_LOG_DIR"
  
  # Rotate if needed (check every write, cheap operation)
  rotate_log_if_needed
  
  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  
  local prefix=""
  [[ -n "$CURRENT_POLL_ID" ]] && prefix="[$CURRENT_POLL_ID] "
  
  echo "${timestamp} ${prefix}${message}" >> "$OCDC_POLL_LOG_FILE"
}

log() {
  echo -e "${BLUE}[poll]${NC} $*" >&2
  _log_to_file "$*"
}

log_success() {
  echo -e "${GREEN}[poll]${NC} $*" >&2
  _log_to_file "$*"
}

log_warn() {
  echo -e "${YELLOW}[poll]${NC} $*" >&2
  _log_to_file "WARN: $*"
}

log_error() {
  echo -e "${RED}[poll]${NC} $*" >&2
  _log_to_file "ERROR: $*"
}

# =============================================================================
# Session Management Functions
# =============================================================================

# Convert seconds to human-readable age (e.g., "2h", "30m", "1d")
format_age() {
  local seconds="$1"
  if [[ $seconds -lt 60 ]]; then
    echo "${seconds}s"
  elif [[ $seconds -lt 3600 ]]; then
    echo "$((seconds / 60))m"
  elif [[ $seconds -lt 86400 ]]; then
    echo "$((seconds / 3600))h"
  else
    echo "$((seconds / 86400))d"
  fi
}

# Get OCDC metadata from a tmux session
# Returns JSON: {"poll": "...", "key": "...", "workspace": "...", "created": "..."}
get_session_metadata() {
  local session="$1"
  local env_output
  env_output=$(tmux show-environment -t "$session" 2>/dev/null) || return 1
  
  # Parse OCDC_* variables from output
  local poll_config key workspace
  poll_config=$(echo "$env_output" | grep '^OCDC_POLL_CONFIG=' | cut -d= -f2- || true)
  key=$(echo "$env_output" | grep '^OCDC_ITEM_KEY=' | cut -d= -f2- || true)
  workspace=$(echo "$env_output" | grep '^OCDC_WORKSPACE=' | cut -d= -f2- || true)
  
  # Get session creation time for age calculation
  local created
  created=$(tmux display-message -t "$session" -p '#{session_created}' 2>/dev/null || echo "0")
  
  jq -n --arg poll "$poll_config" --arg key "$key" \
        --arg workspace "$workspace" --arg created "$created" \
    '{poll: $poll, key: $key, workspace: $workspace, created: $created}'
}

# Find sessions matching a pattern
# Returns newline-separated list of "session_name|item_key" pairs
find_matching_sessions() {
  local pattern="$1"
  
  while IFS= read -r session; do
    [[ -z "$session" ]] && continue
    
    local metadata key poll_config
    metadata=$(get_session_metadata "$session") || continue
    poll_config=$(echo "$metadata" | jq -r '.poll // empty')
    [[ -z "$poll_config" ]] && continue  # Not an ocdc poll session
    
    key=$(echo "$metadata" | jq -r '.key // empty')
    
    # Check for match: exact key, substring key, or substring session name
    if [[ "$key" == "$pattern" ]] || \
       [[ "$key" == *"$pattern"* ]] || \
       [[ "$session" == *"$pattern"* ]]; then
      echo "${session}|${key}"
    fi
  done < <(tmux list-sessions -F '#{session_name}' 2>/dev/null)
}

# Interactive session selection
# Args: session_name|key pairs
# Returns: selected session_name|key pair
select_session() {
  local -a sessions=("$@")
  local count=${#sessions[@]}
  
  if [[ $count -eq 0 ]]; then
    return 1
  elif [[ $count -eq 1 ]]; then
    echo "${sessions[0]}"
    return 0
  fi
  
  # Check if interactive
  if [[ ! -t 0 ]]; then
    log_error "Multiple matches found. Specify a more precise pattern."
    return 1
  fi
  
  echo "Multiple sessions match:" >&2
  for i in "${!sessions[@]}"; do
    local session key
    session="${sessions[$i]%%|*}"
    key="${sessions[$i]#*|}"
    printf "  %d) %s (%s)\n" "$((i+1))" "$session" "$key" >&2
  done
  
  echo -n "Select [1-$count]: " >&2
  read -r choice
  
  if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le $count ]]; then
    echo "${sessions[$((choice-1))]}"
    return 0
  else
    log_error "Invalid selection."
    return 1
  fi
}

# =============================================================================
# Subcommand: sessions
# =============================================================================

poll_sessions_cmd() {
  # Handle --help
  if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
    cat << 'EOF'
Usage: ocdc poll sessions

List active poll-created tmux sessions.

Output columns:
  SESSION   tmux session name
  POLL      poll config ID that created the session
  ITEM      item key (e.g., owner/repo-issue-42)
  AGE       time since session was created
EOF
    return 0
  fi
  
  local now
  now=$(date +%s)
  
  # Header
  printf "%-30s %-16s %-24s %s\n" "SESSION" "POLL" "ITEM" "AGE"
  
  # List all tmux sessions, filter to those with OCDC_POLL_CONFIG
  local found=false
  while IFS= read -r session; do
    [[ -z "$session" ]] && continue
    
    local metadata
    metadata=$(get_session_metadata "$session") || continue
    
    local poll_config key created
    poll_config=$(echo "$metadata" | jq -r '.poll // empty')
    [[ -z "$poll_config" ]] && continue  # Not an ocdc poll session
    
    key=$(echo "$metadata" | jq -r '.key // "unknown"')
    created=$(echo "$metadata" | jq -r '.created // "0"')
    
    local age_seconds age
    age_seconds=$((now - created))
    [[ $age_seconds -lt 0 ]] && age_seconds=0  # Handle clock skew
    age=$(format_age "$age_seconds")
    
    printf "%-30s %-16s %-24s %s\n" "$session" "$poll_config" "$key" "$age"
    found=true
  done < <(tmux list-sessions -F '#{session_name}' 2>/dev/null)
  
  if [[ "$found" == "false" ]]; then
    echo "No active poll sessions." >&2
  fi
}

# =============================================================================
# Subcommand: attach
# =============================================================================

poll_attach_cmd() {
  if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
    cat << 'EOF'
Usage: ocdc poll attach <pattern>

Attach to a poll-created tmux session.

Arguments:
  pattern    Item key or session name (partial match supported)

Examples:
  ocdc poll attach myorg/api-issue-42    # Exact key match
  ocdc poll attach issue-42              # Partial match
  ocdc poll attach api                   # Interactive if multiple
EOF
    return 0
  fi
  
  if [[ $# -eq 0 ]]; then
    log_error "Usage: ocdc poll attach <pattern>"
    log_error "Run 'ocdc poll attach --help' for more information."
    return 1
  fi
  
  local pattern="$1"
  local -a matches=()
  
  while IFS= read -r match; do
    [[ -n "$match" ]] && matches+=("$match")
  done < <(find_matching_sessions "$pattern")
  
  if [[ ${#matches[@]} -eq 0 ]]; then
    log_error "No sessions matching '$pattern'"
    echo "" >&2
    echo "Available sessions:" >&2
    poll_sessions_cmd >&2
    return 1
  fi
  
  local selected
  selected=$(select_session "${matches[@]}") || return 1
  
  local session="${selected%%|*}"
  local key="${selected#*|}"
  
  log "Attaching to: $session ($key)"
  exec tmux attach -t "$session"
}

# =============================================================================
# Subcommand: logs
# =============================================================================

poll_logs_cmd() {
  local follow=false
  local poll_filter=""
  local lines=50
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --follow|-f) follow=true; shift ;;
      --poll) poll_filter="$2"; shift 2 ;;
      --lines|-n) lines="$2"; shift 2 ;;
      --help|-h)
        cat << 'EOF'
Usage: ocdc poll logs [options]

View poll orchestrator logs.

Options:
  --follow, -f       Follow log output (like tail -f)
  --poll <name>      Filter by poll config ID
  --lines, -n <num>  Number of lines to show (default: 50)
  --help             Show this help

Examples:
  ocdc poll logs                     # View recent logs
  ocdc poll logs --follow            # Follow logs in real-time
  ocdc poll logs --poll github-issues  # Filter by poll config
EOF
        return 0
        ;;
      *)
        log_error "Unknown option: $1"
        return 1
        ;;
    esac
  done
  
  if [[ ! -f "$OCDC_POLL_LOG_FILE" ]]; then
    log_warn "No log file found at $OCDC_POLL_LOG_FILE"
    return 0
  fi
  
  if [[ "$follow" == "true" ]]; then
    if [[ -n "$poll_filter" ]]; then
      tail -f "$OCDC_POLL_LOG_FILE" | grep --line-buffered "\\[$poll_filter\\]"
    else
      tail -f "$OCDC_POLL_LOG_FILE"
    fi
  else
    if [[ -n "$poll_filter" ]]; then
      grep "\\[$poll_filter\\]" "$OCDC_POLL_LOG_FILE" | tail -n "$lines"
    else
      tail -n "$lines" "$OCDC_POLL_LOG_FILE"
    fi
  fi
}

# Check required dependencies
check_dependencies() {
  local missing=()
  
  command -v jq >/dev/null 2>&1 || missing+=("jq")
  command -v tmux >/dev/null 2>&1 || missing+=("tmux")
  command -v opencode >/dev/null 2>&1 || missing+=("opencode")
  
  if [[ ${#missing[@]} -gt 0 ]]; then
    log_error "Missing required dependencies: ${missing[*]}"
    log_error "Install with: brew install ${missing[*]}"
    return 1
  fi
  return 0
}

# Sanitize a string to be safe for use in file paths and tmux session names
# Only allows alphanumeric characters, hyphens, underscores, and dots
sanitize_name() {
  local input="$1"
  echo "$input" | tr -cd '[:alnum:]-_.'
}

show_help() {
  cat << 'EOF'
Usage: ocdc poll [command] [options]

Poll configured sources and spawn OpenCode sessions for new items.

Commands:
  sessions            List active poll-created sessions
  attach <pattern>    Attach to a session by key or name
  logs [options]      View poll logs

Options:
  --once              Run one poll cycle and exit (default behavior)
  --daemon            Run continuously, polling every interval
  --interval <secs>   Poll interval in seconds (default: 300, requires --daemon)
  --dry-run           Show what would be done without executing
  --config <id>       Only run specific config by id
  --verbose           Show detailed output
  --help              Show this help

Examples:
  ocdc poll                    # Run all enabled polls once
  ocdc poll --dry-run          # Preview what would happen
  ocdc poll --config github-issues  # Run only github-issues poll
  ocdc poll sessions           # List active sessions
  ocdc poll attach issue-42    # Attach to a matching session
  ocdc poll logs --follow      # Follow poll logs
EOF
}

# Check if an item has been processed
is_processed() {
  local key="$1"
  jq -e --arg key "$key" '.[$key] != null' "$STATE_FILE" >/dev/null 2>&1
}

# Mark an item as processed (with file locking to prevent race conditions)
mark_processed() {
  local key="$1"
  local config_id="$2"
  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  
  # Use mkdir-based locking for cross-platform compatibility (flock not on macOS)
  lock_file "${STATE_FILE}.lock"
  # Ensure lock is released even if jq/mv fails (set -e would otherwise leave stale lock)
  trap 'unlock_file "${STATE_FILE}.lock"' EXIT
  
  local tmp
  tmp=$(mktemp)
  jq --arg key "$key" --arg config "$config_id" --arg ts "$timestamp" \
    '.[$key] = {config: $config, processed_at: $ts}' "$STATE_FILE" > "$tmp"
  mv "$tmp" "$STATE_FILE"
  
  trap - EXIT
  unlock_file "${STATE_FILE}.lock"
}

# Get item field using jq mapping
get_item_field() {
  local item_json="$1"
  local jq_expr="$2"
  
  echo "$item_json" | jq -r "$jq_expr"
}

# Expand ~ in paths
expand_path() {
  local path="$1"
  echo "${path/#\~/$HOME}"
}

# Process a single poll config
process_poll() {
  local config_file="$1"
  
  # Validate config before processing
  if ! poll_config_validate "$config_file"; then
    log_error "Invalid config file: $config_file"
    return 1
  fi
  
  # Also validate against JSON schema if available
  local schema_output
  if ! schema_output=$(poll_config_validate_schema "$config_file" 2>&1); then
    log_error "Config failed schema validation: $config_file"
    log_error "$schema_output"
    return 1
  fi
  
  local config_id
  config_id=$(poll_config_get "$config_file" ".id")
  
  # Set current poll ID for structured logging
  CURRENT_POLL_ID="$config_id"
  
  log "Processing poll: $config_id"
  
  # Check if enabled
  local enabled
  enabled=$(poll_config_get_with_default "$config_file" ".enabled" "true")
  if [[ "$enabled" != "true" ]]; then
    log "  Skipping (disabled)"
    return 0
  fi
  
  # Get effective fetch command (built from fetch options or fetch_command)
  local fetch_cmd
  fetch_cmd=$(poll_config_get_effective_fetch_command "$config_file")
  
  # Execute fetch command
  log "  Fetching items..."
  [[ "$VERBOSE" == "true" ]] && log "  Command: $fetch_cmd"
  local items_json
  if ! items_json=$(bash -c "$fetch_cmd" 2>&1); then
    log_error "  Fetch command failed: $items_json"
    return 1
  fi
  
  # Check if we got valid JSON array
  local item_count
  item_count=$(echo "$items_json" | jq -r 'length' 2>/dev/null || echo "0")
  log "  Found $item_count items"
  
  if [[ "$item_count" == "0" ]]; then
    return 0
  fi
  
  # Get effective mapping expressions (merged with defaults)
  local item_mapping_json
  item_mapping_json=$(poll_config_get_effective_item_mapping "$config_file")
  
  local key_expr repo_expr repo_short_expr number_expr title_expr body_expr url_expr branch_expr
  key_expr=$(echo "$item_mapping_json" | jq -r '.key')
  repo_expr=$(echo "$item_mapping_json" | jq -r '.repo')
  repo_short_expr=$(echo "$item_mapping_json" | jq -r '.repo_short')
  number_expr=$(echo "$item_mapping_json" | jq -r '.number')
  title_expr=$(echo "$item_mapping_json" | jq -r '.title')
  body_expr=$(echo "$item_mapping_json" | jq -r '.body')
  url_expr=$(echo "$item_mapping_json" | jq -r '.url')
  branch_expr=$(echo "$item_mapping_json" | jq -r '.branch')
  
  # Get effective prompt template (or default)
  local prompt_template
  prompt_template=$(poll_config_get_effective_prompt "$config_file")
  
  # Get effective session name template (or default)
  local session_template
  session_template=$(poll_config_get_effective_session_name "$config_file")
  
  # Get effective agent (or default based on source type)
  local session_agent
  session_agent=$(poll_config_get_effective_agent "$config_file")
  
  # Validate agent to prevent command injection from malicious configs
  case "$session_agent" in
    plan|code|architect|build|review|pm) ;;  # Known safe agents
    *)
      log_warn "Unknown agent '$session_agent', defaulting to 'plan'"
      session_agent="plan"
      ;;
  esac
  
  # Get source type (required in new schema)
  local source_type
  source_type=$(poll_config_get "$config_file" ".source_type")
  
  # Get repo filters for matching
  local repo_filters_json
  repo_filters_json=$(poll_config_get_repo_filters "$config_file")
  
  # Process each item
  echo "$items_json" | jq -c '.[]' | while read -r item; do
    # Extract fields
    local key repo repo_short number title body url branch
    key=$(get_item_field "$item" "$key_expr")
    repo=$(get_item_field "$item" "$repo_expr")
    repo_short=$(get_item_field "$item" "$repo_short_expr")
    number=$(get_item_field "$item" "$number_expr")
    title=$(get_item_field "$item" "$title_expr")
    body=$(get_item_field "$item" "$body_expr")
    url=$(get_item_field "$item" "$url_expr")
    branch=$(get_item_field "$item" "$branch_expr")
    
    # Check if already processed
    if is_processed "$key"; then
      [[ "$VERBOSE" == "true" ]] && log "  Skipping $key (already processed)"
      continue
    fi
    
    log "  New item: $key"
    log "    Repo: $repo"
    log "    Branch: $branch"
    log "    Title: $title"
    
    # Match item against repo filters to get repo_path
    local repo_path
    repo_path=$(poll_config_match_repo_filter "$item" "$repo_filters_json")
    if [[ -z "$repo_path" ]]; then
      log_warn "    No matching repo_filter for item, skipping"
      [[ "$VERBOSE" == "true" ]] && log "    Item JSON: $item"
      continue
    fi
    repo_path=$(expand_path "$repo_path")
    
    if [[ "$DRY_RUN" == "true" ]]; then
      log "    [DRY-RUN] Would create devcontainer and session"
      continue
    fi
    
    # Check repo path exists
    if [[ ! -d "$repo_path" ]]; then
      log_error "    Repo path does not exist: $repo_path"
      continue
    fi
    
    # Render templates
    local session_name_raw session_name
    session_name_raw=$(poll_config_render_template "$session_template" \
      key="$key" \
      repo="$repo" \
      repo_short="$repo_short" \
      number="$number" \
      title="$title" \
      branch="$branch")
    # Sanitize session name to prevent command injection and path traversal
    # Truncate to 200 chars to avoid tmux session name limits
    session_name=$(sanitize_name "$session_name_raw" | cut -c1-200)
    
    if [[ -z "$session_name" ]]; then
      log_error "    Session name is empty after sanitization"
      continue
    fi
    
    local prompt
    prompt=$(poll_config_render_template "$prompt_template" \
      key="$key" \
      repo="$repo" \
      repo_short="$repo_short" \
      number="$number" \
      title="$title" \
      body="$body" \
      url="$url" \
      branch="$branch")
    
    # Create devcontainer clone
    log "    Creating devcontainer clone..."
    local clone_dir="${OCDC_CLONES_DIR}/${repo_short}/${branch}"
    
    if [[ ! -d "$clone_dir" ]]; then
      if ! (cd "$repo_path" && ocdc up "$branch" --no-open 2>&1); then
        log_error "    Failed to create devcontainer"
        continue
      fi
    fi
    
    # Check if tmux session already exists
    if tmux has-session -t "$session_name" 2>/dev/null; then
      log_warn "    Session $session_name already exists"
      mark_processed "$key" "$config_id"
      continue
    fi
    
    # Create tmux session with opencode
    log "    Creating tmux session: $session_name"
    
    # Write prompt to temp file to avoid shell escaping issues
    # Use sanitized session_name in filename to prevent path traversal
    local prompt_file
    prompt_file="${OCDC_POLL_STATE_DIR}/prompt-${session_name}.txt"
    printf '%s' "$prompt" > "$prompt_file"
    
    # Build opencode command with agent flag (quote to prevent injection)
    local opencode_cmd="opencode --agent \"$session_agent\""
    
    # Create tmux session running opencode with the prompt
    # Set OCDC_* environment variables so the plugin knows the context
    # The session runs in the clone directory
    if ! tmux new-session -d -s "$session_name" -c "$clone_dir" \
      -e "OCDC_WORKSPACE=$clone_dir" \
      -e "OCDC_BRANCH=$branch" \
      -e "OCDC_SOURCE_URL=$url" \
      -e "OCDC_SOURCE_TYPE=$source_type" \
      -e "OCDC_POLL_CONFIG=$config_id" \
      -e "OCDC_ITEM_KEY=$key" \
      "$opencode_cmd --prompt \"\$(cat '$prompt_file')\"; rm -f '$prompt_file'; echo 'Session complete. Press enter to close...'; read"; then
      log_error "    Failed to create tmux session"
      rm -f "$prompt_file"  # Cleanup prompt file on failure
      continue
    fi
    
    log_success "    Session $session_name created"
    log "    Attach with: tmux attach -t $session_name"
    mark_processed "$key" "$config_id"
  done
  
  # Clear poll ID after processing
  CURRENT_POLL_ID=""
  
  return 0
}

# Main
main() {
  # Check for subcommands first (before option parsing)
  case "${1:-}" in
    sessions) shift; poll_sessions_cmd "$@"; exit $? ;;
    attach)   shift; poll_attach_cmd "$@"; exit $? ;;
    logs)     shift; poll_logs_cmd "$@"; exit $? ;;
  esac
  
  # Parse arguments (check for --help first, before checking dependencies)
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --once)
        DAEMON=false
        shift
        ;;
      --daemon)
        DAEMON=true
        shift
        ;;
      --interval)
        INTERVAL="$2"
        shift 2
        ;;
      --dry-run)
        DRY_RUN=true
        shift
        ;;
      --config)
        SINGLE_CONFIG="$2"
        shift 2
        ;;
      --verbose)
        VERBOSE=true
        shift
        ;;
      --help|-h)
        show_help
        exit 0
        ;;
      *)
        log_error "Unknown option: $1"
        show_help
        exit 1
        ;;
    esac
  done
  
  # Check dependencies after parsing arguments
  check_dependencies || exit 1
  
  if [[ "$DAEMON" == "true" ]]; then
    log "Starting poll daemon (interval: ${INTERVAL}s)"
    while true; do
      run_poll_cycle
      log "Sleeping for ${INTERVAL}s..."
      sleep "$INTERVAL"
    done
  else
    run_poll_cycle
  fi
}

# Run one poll cycle
run_poll_cycle() {
  # Find poll configs
  if [[ ! -d "$OCDC_POLLS_DIR" ]]; then
    log_warn "No polls directory found at $OCDC_POLLS_DIR"
    return 0
  fi
  
  local found_configs=false
  
  for config_file in "$OCDC_POLLS_DIR"/*.yaml "$OCDC_POLLS_DIR"/*.yml; do
    [[ -f "$config_file" ]] || continue
    
    # If single config specified, skip others
    if [[ -n "$SINGLE_CONFIG" ]]; then
      local config_id
      config_id=$(poll_config_get "$config_file" ".id")
      if [[ "$config_id" != "$SINGLE_CONFIG" ]]; then
        continue
      fi
    fi
    
    found_configs=true
    process_poll "$config_file" || true
  done
  
  if [[ "$found_configs" == "false" ]]; then
    if [[ -n "$SINGLE_CONFIG" ]]; then
      log_error "Config '$SINGLE_CONFIG' not found"
      return 1
    else
      log "No poll configs found in $OCDC_POLLS_DIR"
    fi
  fi
  
  log "Poll cycle complete"
}

main "$@"
